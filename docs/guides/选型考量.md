# 选型介绍

## 通用
- 语言: typescript
- 静态检查: tslint

### 说明
JS 在经过 ES5, ES6, ES7 等几代演进之后，开发效率有了很大的提升，但是在开发大型项目的时候，我们还是一直在被 JS 动态类型的问题一直困扰着。虽然动态类型在最初算是 JS 的一个特性，但是他不可预测的问题在代码量庞大之后开始逐渐凸显出来，如：

- 编写代码的时候不能确定变量类型，需要做很多冗余判断
- 调用函数时不能确定返回类型
- 同一个变量名在不同的方法里类型不同
- 重构时需要非常谨慎

在传统的前端项目里，当我们第一次接触到别人的代码的时候，我们对于变量的类型都几乎只能通过上下文或者是变量名来推断。这时如果我们要操作变量的话就需要特别的小心，要考虑到变量在不同情况下可能有不同的类型，更多的时候我们甚至必须在浏览器里运行一遍才能确定变量的类型。当然，更多的时候我们用的方法还是约定，比如我们约定 `name` 就是字符串、`count` 就是数字、`getUser()` 返回的就是用户信息。但是这么做不具备强制约束性。在大型项目里，不具备强制性的约束，都是无效的约束。开发人员尤其是初级开发，不可能在每时每刻都会遵守这些约定，就像破窗效应，一旦有一次破坏约定的行为发生，后面就会有更多的发生。而且这种破坏约定的写法不是很容易去排查，往往需要运行时才能察觉出来。

针对这些 JS 弱类型带来的问题，我们使用 typescript 来规避。在代码的编写中，我们要求尽量去明确每个变量的类型，这样可以在开发过程中就避免很多类型错误，使得代码更加健壮。其他人在接入或者修改代码的时候也更加有底气。

基于类型，我们可以在未来做更多的事情，比如我们可以做细致到方法的 treeshake，我们可以做代码的调用分析等等。

---
## 客户端
- 框架: react
- 路由: react-router
- 数据流管理: mobx
- 网络请求: fetch
- 构建: webpack
- 样式处理: scss (postcss)

### 说明

React 是目前比较流行的前端框架，因为它做的事情比较明确：渲染视图。它可以跟其他的工具随意组合，可选性比较多，而且生态系统比较丰富。当然，最主要的原因是他的类型系统非常明确，和 typescript 结合的非常好。相比较而言， vue 和它相关生态在设计之初没有考虑到结合 TS 的事，导致框架里暴露出来很多变量都是 `any` 的类型。Angular 虽然和 TS 结合的也很好，但是它的模板系统却不支持 TS 的类型系统。

数据流管理的工具我们尝试了很多，比如 vuex、redux，但是他们都不够理想。尤其是 redux 复杂的 action、reducer 写法让我们开发过程中很不愿意去添加新的 state，而且还增加了代码量。在对比过之后，我们还是觉得 mobx 最合适，和 TS 结合的也很好。

移动端的系统更新速度非常快，很多新特性移动端都不用打 polyfill 了，所以网络请求我们考虑向前兼容使用 fetch。

---
## 服务端
- 运行库: node
- 框架: koa
- RPC 协议: thrift

服务端的运行框架，我们直接用 koa 加上一些自己写的中间件，因为这一块不会太复杂，我们可以根据自己的需求在某个功能点上做深度开发。